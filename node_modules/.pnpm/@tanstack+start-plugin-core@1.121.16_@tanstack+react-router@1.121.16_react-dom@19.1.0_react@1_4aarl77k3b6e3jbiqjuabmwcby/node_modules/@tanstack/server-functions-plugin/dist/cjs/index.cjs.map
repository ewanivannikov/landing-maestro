{"version":3,"file":"index.cjs","sources":["../../src/index.ts"],"sourcesContent":["import { mkdirSync, readFileSync, writeFileSync } from 'node:fs'\nimport path from 'node:path'\nimport {\n  TanStackDirectiveFunctionsPlugin,\n  TanStackDirectiveFunctionsPluginEnv,\n} from '@tanstack/directive-functions-plugin'\nimport type { Plugin } from 'vite'\nimport type {\n  DirectiveFn,\n  ReplacerFn,\n} from '@tanstack/directive-functions-plugin'\n\nexport type CreateRpcFn = (\n  functionId: string,\n  serverBase: string,\n  splitImportFn?: string,\n) => any\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var TSR_directiveFnsById: Record<string, DirectiveFn>\n}\n\nexport type ServerFnPluginOpts = {\n  /**\n   * The virtual import ID that will be used to import the server function manifest.\n   * This virtual import ID will be used in the server build to import the manifest\n   * and its modules.\n   */\n  manifestVirtualImportId: string\n  /**\n   * The path to the manifest file that will be created during the build process.\n   * This file will be used to import the modules for the server functions in your\n   * server handler.\n   *\n   * @default 'node_modules/.tanstack-start/server-functions-manifest.json'\n   */\n  manifestOutputFilename?: string\n  client: ServerFnPluginEnvOpts\n  ssr: ServerFnPluginEnvOpts\n  server: ServerFnPluginEnvOpts\n  importer?: (fn: DirectiveFn) => Promise<any>\n}\n\nconst defaultManifestFilename =\n  'node_modules/.tanstack-start/server-functions-manifest.json'\n\nexport type ServerFnPluginEnvOpts = {\n  getRuntimeCode: () => string\n  replacer: ReplacerFn\n}\n\nexport function createTanStackServerFnPlugin(opts: ServerFnPluginOpts): {\n  client: Array<Plugin>\n  ssr: Array<Plugin>\n  server: Array<Plugin>\n} {\n  const ROOT = process.cwd()\n\n  globalThis.TSR_directiveFnsById = {}\n\n  const onDirectiveFnsById = (d: Record<string, DirectiveFn>) => {\n    // When directives are compiled, save them to our global variable\n    // This variable will be used both during development to incrementally\n    // look up server functions and during build/production to produce a\n    // static manifest that can be read by the server build\n    Object.assign(\n      globalThis.TSR_directiveFnsById,\n      Object.fromEntries(\n        Object.entries(d).map(([id, fn]) => [\n          id,\n          {\n            ...fn,\n            // This importer is required for the development server to\n            // work. It's also required in production, but cannot be serialized\n            // into the manifest because it's a dynamic import. Instead, as you'll\n            // see below, we augment the manifest output with a code-generated importer\n            // that looks exactly like this.\n            importer: () =>\n              opts.importer ? opts.importer(fn) : import(fn.extractedFilename),\n          },\n        ]),\n      ),\n    )\n  }\n\n  const manifestFilename =\n    opts.manifestOutputFilename || defaultManifestFilename\n\n  const directive = 'use server'\n  const directiveLabel = 'Server Function'\n\n  return {\n    client: [\n      // The client plugin is used to compile the client directives\n      // and save them so we can create a manifest\n      TanStackDirectiveFunctionsPlugin({\n        envLabel: 'Client',\n        directive,\n        directiveLabel,\n        getRuntimeCode: opts.client.getRuntimeCode,\n        replacer: opts.client.replacer,\n        onDirectiveFnsById,\n      }),\n      {\n        // Now that we have the directiveFnsById, we need to create a new\n        // virtual module that can be used to import that manifest\n        name: 'tanstack-start-server-fn-vite-plugin-build-client',\n        generateBundle() {\n          // In production, we create a manifest so we can\n          // access it later in the server build, which likely does not run in the\n          // same vite build environment. This is essentially a\n          // serialized state transfer from the client build to the server\n          // build.\n\n          // Ensure the manifest directory exists\n          mkdirSync(path.join(ROOT, path.dirname(manifestFilename)), {\n            recursive: true,\n          })\n\n          // Write the manifest to disk\n          writeFileSync(\n            path.join(ROOT, manifestFilename),\n            JSON.stringify(\n              Object.fromEntries(\n                Object.entries(globalThis.TSR_directiveFnsById).map(\n                  ([id, fn]) => [\n                    id,\n                    {\n                      functionName: fn.functionName,\n                      extractedFilename: fn.extractedFilename,\n                    },\n                  ],\n                ),\n              ),\n            ),\n          )\n        },\n      },\n    ],\n    ssr: [\n      // The SSR plugin is used to compile the server directives\n      TanStackDirectiveFunctionsPlugin({\n        envLabel: 'SSR',\n        directive,\n        directiveLabel,\n        getRuntimeCode: opts.ssr.getRuntimeCode,\n        replacer: opts.ssr.replacer,\n        onDirectiveFnsById,\n      }),\n    ],\n    server: [\n      {\n        // On the server, we need to be able to read the server-function manifest from the client build.\n        // This is likely used in the handler for server functions, so we can find the server function\n        // by its ID, import it, and call it. We can't do this in memory here because the builds happen in isolation,\n        // so the manifest is like a serialized state from the client build to the server build\n        name: 'tanstack-start-server-fn-vite-plugin-manifest-server',\n        enforce: 'pre',\n        resolveId(id) {\n          if (id === opts.manifestVirtualImportId) {\n            return resolveViteId(id)\n          }\n\n          return undefined\n        },\n        load(id) {\n          if (id !== resolveViteId(opts.manifestVirtualImportId)) {\n            return undefined\n          }\n\n          // In development, we **can** use the in-memory manifest, and we should\n          // since it will be incrementally updated as we use the app and dynamic\n          // imports are triggered.\n          if (process.env.NODE_ENV === 'development') {\n            return `export default globalThis.TSR_directiveFnsById`\n          }\n\n          // In production, we need to read the manifest from the client build.\n          // The manifest at that point should contain the full set of server functions\n          // that were found in the client build.\n          const manifest = JSON.parse(\n            readFileSync(path.join(ROOT, manifestFilename), 'utf-8'),\n          )\n\n          // The manifest has a lot of information, but for now we only need to\n          // provide the function ID for lookup and the importer for loading\n          // This should keep the manifest small for now.\n          const manifestWithImports = `\n          export default {${Object.entries(manifest)\n            .map(\n              ([id, fn]: any) =>\n                `'${id}': {\n                  functionName: '${fn.functionName}',\n                  importer: () => import(${JSON.stringify(fn.extractedFilename)})\n                }`,\n            )\n            .join(',')}}`\n\n          return manifestWithImports\n        },\n      },\n      // On the server, we need to compile the server functions\n      // so they can be called by other server functions.\n      // This is also where we split the server function into a separate file\n      // so we can load them on demand in the worker.\n      TanStackDirectiveFunctionsPlugin({\n        envLabel: 'Server',\n        directive,\n        directiveLabel,\n        getRuntimeCode: opts.server.getRuntimeCode,\n        replacer: opts.server.replacer,\n        onDirectiveFnsById,\n      }),\n    ],\n  }\n}\n\nexport interface TanStackServerFnPluginEnvOpts {\n  /**\n   * The virtual import ID that will be used to import the server function manifest.\n   * This virtual import ID will be used in the server build to import the manifest\n   * and its modules.\n   */\n  manifestVirtualImportId: string\n  /**\n   * The path to the manifest file that will be created during the build process.\n   * This file will be used to import the modules for the server functions in your\n   * server handler.\n   *\n   * @default 'node_modules/.tanstack-start/server-functions-manifest.json'\n   */\n  manifestOutputFilename?: string\n  client: {\n    envName?: string\n    getRuntimeCode: () => string\n    replacer: ReplacerFn\n  }\n  server: {\n    envName?: string\n    getRuntimeCode: () => string\n    replacer: ReplacerFn\n  }\n  importer?: (fn: DirectiveFn) => Promise<any>\n}\n\nexport function TanStackServerFnPluginEnv(\n  opts: TanStackServerFnPluginEnvOpts,\n): Array<Plugin> {\n  opts = {\n    ...opts,\n    client: {\n      ...opts.client,\n      envName: opts.client.envName || 'client',\n    },\n    server: {\n      ...opts.server,\n      envName: opts.server.envName || 'server',\n    },\n  }\n\n  const root = process.cwd()\n\n  globalThis.TSR_directiveFnsById = {}\n\n  const onDirectiveFnsById = (d: Record<string, DirectiveFn>) => {\n    // When directives are compiled, save them to our global variable\n    // This variable will be used both during development to incrementally\n    // look up server functions and during build/production to produce a\n    // static manifest that can be read by the server build\n    Object.assign(\n      globalThis.TSR_directiveFnsById,\n      Object.fromEntries(\n        Object.entries(d).map(([id, fn]) => [\n          id,\n          {\n            ...fn,\n            // This importer is required for the development server to\n            // work. It's also required in production, but cannot be serialized\n            // into the manifest because it's a dynamic import. Instead, as you'll\n            // see below, we augment the manifest output with a code-generated importer\n            // that looks exactly like this.\n            importer: () =>\n              opts.importer ? opts.importer(fn) : import(fn.extractedFilename),\n          },\n        ]),\n      ),\n    )\n  }\n\n  const manifestFilename =\n    opts.manifestOutputFilename || defaultManifestFilename\n\n  const directive = 'use server'\n  const directiveLabel = 'Server Function'\n\n  return [\n    // The client plugin is used to compile the client directives\n    // and save them so we can create a manifest\n    TanStackDirectiveFunctionsPluginEnv({\n      directive,\n      directiveLabel,\n      onDirectiveFnsById,\n      environments: {\n        client: {\n          envLabel: 'Client',\n          getRuntimeCode: opts.client.getRuntimeCode,\n          replacer: opts.client.replacer,\n          envName: opts.client.envName,\n        },\n        server: {\n          envLabel: 'Server',\n          getRuntimeCode: opts.server.getRuntimeCode,\n          replacer: opts.server.replacer,\n          envName: opts.server.envName,\n        },\n      },\n    }),\n    {\n      // Now that we have the directiveFnsById, we need to create a new\n      // virtual module that can be used to import that manifest\n      name: 'tanstack-start-server-fn-vite-plugin-build-client',\n      applyToEnvironment(environment) {\n        return environment.name === opts.client.envName\n      },\n      buildEnd() {\n        // In production, we create a manifest so we can\n        // access it later in the server build, which likely does not run in the\n        // same vite build environment. This is essentially a\n        // serialized state transfer from the client build to the server\n        // build.\n\n        // Ensure the manifest directory exists\n        mkdirSync(path.join(root, path.dirname(manifestFilename)), {\n          recursive: true,\n        })\n\n        // Write the manifest to disk\n        writeFileSync(\n          path.join(root, manifestFilename),\n          JSON.stringify(\n            Object.fromEntries(\n              Object.entries(globalThis.TSR_directiveFnsById).map(\n                ([id, fn]) => [\n                  id,\n                  {\n                    functionName: fn.functionName,\n                    extractedFilename: fn.extractedFilename,\n                  },\n                ],\n              ),\n            ),\n          ),\n        )\n      },\n    },\n    {\n      // On the server, we need to be able to read the server-function manifest from the client build.\n      // This is likely used in the handler for server functions, so we can find the server function\n      // by its ID, import it, and call it. We can't do this in memory here because the builds happen in isolation,\n      // so the manifest is like a serialized state from the client build to the server build\n      name: 'tanstack-start-server-fn-vite-plugin-manifest-server',\n      enforce: 'pre',\n      // applyToEnvironment(environment) {\n      //   return environment.name === opts.server.envName\n      // },\n      resolveId(id) {\n        if (id === opts.manifestVirtualImportId) {\n          return resolveViteId(id)\n        }\n\n        return undefined\n      },\n      load(id) {\n        if (id !== resolveViteId(opts.manifestVirtualImportId)) {\n          return undefined\n        }\n\n        // In development, we **can** use the in-memory manifest, and we should\n        // since it will be incrementally updated as we use the app and dynamic\n        // imports are triggered.\n        if (process.env.NODE_ENV === 'development') {\n          return `export default globalThis.TSR_directiveFnsById`\n        }\n\n        // In production, we need to read the manifest from the client build.\n        // The manifest at that point should contain the full set of server functions\n        // that were found in the client build.\n        const manifest = JSON.parse(\n          readFileSync(path.join(root, manifestFilename), 'utf-8'),\n        )\n\n        // The manifest has a lot of information, but for now we only need to\n        // provide the function ID for lookup and the importer for loading\n        // This should keep the manifest small for now.\n        const manifestWithImports = `\n          export default {${Object.entries(manifest)\n            .map(\n              ([id, fn]: any) =>\n                `'${id}': {\n                  functionName: '${fn.functionName}',\n                  importer: () => import(${JSON.stringify(fn.extractedFilename)})\n                }`,\n            )\n            .join(',')}}`\n\n        return manifestWithImports\n      },\n    },\n  ]\n}\n\nfunction resolveViteId(id: string) {\n  return `\\0${id}`\n}\n"],"names":["TanStackDirectiveFunctionsPlugin","mkdirSync","writeFileSync","readFileSync","id","TanStackDirectiveFunctionsPluginEnv"],"mappings":"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"}