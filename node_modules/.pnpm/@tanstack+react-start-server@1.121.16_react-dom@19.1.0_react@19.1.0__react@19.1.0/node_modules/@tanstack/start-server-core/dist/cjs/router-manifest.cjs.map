{"version":3,"file":"router-manifest.cjs","sources":["../../src/router-manifest.ts"],"sourcesContent":["import { joinPaths, rootRouteId } from '@tanstack/router-core'\nimport { VIRTUAL_MODULES } from './virtual-modules'\nimport { loadVirtualModule } from './loadVirtualModule'\n\n/**\n * @description Returns the router manifest that should be sent to the client.\n * This includes only the assets and preloads for the current route and any\n * special assets that are needed for the client. It does not include relationships\n * between routes or any other data that is not needed for the client.\n */\nexport async function getStartManifest(opts: { basePath: string }) {\n  const { tsrStartManifest } = await loadVirtualModule(\n    VIRTUAL_MODULES.startManifest,\n  )\n  const startManifest = tsrStartManifest()\n\n  const rootRoute = (startManifest.routes[rootRouteId] =\n    startManifest.routes[rootRouteId] || {})\n\n  rootRoute.assets = rootRoute.assets || []\n\n  // Get the entry for the client\n  // const ClientManifest = getManifest('client')\n\n  // const importPath =\n  //   ClientManifest.inputs[ClientManifest.handler]?.output.path\n  // if (!importPath) {\n  //   invariant(importPath, 'Could not find client entry in manifest')\n  // }\n\n  if (process.env.NODE_ENV === 'development' && !process.env.TSS_CLIENT_ENTRY) {\n    throw new Error(\n      'tanstack/start-server-core: TSS_CLIENT_ENTRY must be defined in your environment for getStartManifest()',\n    )\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // Always fake that HMR is ready\n    // const CLIENT_BASE = sanitizeBase(process.env.TSS_CLIENT_BASE || '')\n\n    // if (!CLIENT_BASE) {\n    //   throw new Error(\n    //     'tanstack/start-router-manifest: TSS_CLIENT_BASE must be defined in your environment for getFullRouterManifest()',\n    //   )\n    // }\n\n    const clientEntry = joinPaths([opts.basePath, process.env.TSS_CLIENT_ENTRY])\n\n    const script = `${globalThis.TSS_INJECTED_HEAD_SCRIPTS ? globalThis.TSS_INJECTED_HEAD_SCRIPTS + '; ' : ''}import('${clientEntry}')`\n\n    rootRoute.assets.push({\n      tag: 'script',\n      attrs: {\n        type: 'module',\n        suppressHydrationWarning: true,\n        async: true,\n      },\n      children: script,\n    })\n  }\n\n  const manifest = {\n    ...startManifest,\n    routes: Object.fromEntries(\n      Object.entries(startManifest.routes).map(([k, v]) => {\n        const { preloads, assets } = v\n        return [\n          k,\n          {\n            preloads,\n            assets,\n          },\n        ]\n      }),\n    ),\n  }\n\n  // Strip out anything that isn't needed for the client\n  return manifest\n}\n"],"names":["loadVirtualModule","VIRTUAL_MODULES","rootRouteId","joinPaths"],"mappings":";;;;;AAUA,eAAsB,iBAAiB,MAA4B;AAC3D,QAAA,EAAE,iBAAiB,IAAI,MAAMA,kBAAA;AAAA,IACjCC,+BAAgB;AAAA,EAClB;AACA,QAAM,gBAAgB,iBAAiB;AAEjC,QAAA,YAAa,cAAc,OAAOC,WAAAA,WAAW,IACjD,cAAc,OAAOA,WAAW,WAAA,KAAK,CAAC;AAE9B,YAAA,SAAS,UAAU,UAAU,CAAC;AAWxC,MAAI,QAAQ,IAAI,aAAa,iBAAiB,CAAC,QAAQ,IAAI,kBAAkB;AAC3E,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EAAA;AAGE,MAAA,QAAQ,IAAI,aAAa,eAAe;AAUpC,UAAA,cAAcC,qBAAU,CAAC,KAAK,UAAU,QAAQ,IAAI,gBAAgB,CAAC;AAErE,UAAA,SAAS,GAAG,WAAW,4BAA4B,WAAW,4BAA4B,OAAO,EAAE,WAAW,WAAW;AAE/H,cAAU,OAAO,KAAK;AAAA,MACpB,KAAK;AAAA,MACL,OAAO;AAAA,QACL,MAAM;AAAA,QACN,0BAA0B;AAAA,QAC1B,OAAO;AAAA,MACT;AAAA,MACA,UAAU;AAAA,IAAA,CACX;AAAA,EAAA;AAGH,QAAM,WAAW;AAAA,IACf,GAAG;AAAA,IACH,QAAQ,OAAO;AAAA,MACb,OAAO,QAAQ,cAAc,MAAM,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM;AAC7C,cAAA,EAAE,UAAU,OAAA,IAAW;AACtB,eAAA;AAAA,UACL;AAAA,UACA;AAAA,YACE;AAAA,YACA;AAAA,UAAA;AAAA,QAEJ;AAAA,MACD,CAAA;AAAA,IAAA;AAAA,EAEL;AAGO,SAAA;AACT;;"}