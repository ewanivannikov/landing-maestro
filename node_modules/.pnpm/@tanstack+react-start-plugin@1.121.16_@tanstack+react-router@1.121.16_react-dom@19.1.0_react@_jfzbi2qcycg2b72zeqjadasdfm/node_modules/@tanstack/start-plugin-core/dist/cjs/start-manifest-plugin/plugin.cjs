"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const node_fs = require("node:fs");
const path = require("node:path");
const ufo = require("ufo");
const routerCore = require("@tanstack/router-core");
const startServerCore = require("@tanstack/start-server-core");
const utils = require("../utils.cjs");
const constants = require("../constants.cjs");
const getCSSRecursively = (file, filesByRouteFilePath, basePath) => {
  const result = [];
  for (const cssFile of file.css ?? []) {
    result.push({
      tag: "link",
      attrs: {
        rel: "stylesheet",
        href: ufo.joinURL(basePath, cssFile),
        type: "text/css"
      }
    });
  }
  for (const imp of file.imports ?? []) {
    const importInfo = filesByRouteFilePath[imp];
    if (importInfo) {
      result.push(
        ...getCSSRecursively(importInfo, filesByRouteFilePath, basePath)
      );
    }
  }
  return result;
};
const resolvedModuleId = utils.resolveViteId(startServerCore.VIRTUAL_MODULES.startManifest);
function startManifestPlugin(opts) {
  let config;
  return {
    name: "tanstack-start:start-manifest-plugin",
    enforce: "pre",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
    },
    // configEnvironment(env, envConfig) {
    //   config = envConfig.
    // },
    resolveId: {
      filter: { id: new RegExp(startServerCore.VIRTUAL_MODULES.startManifest) },
      handler(id) {
        if (id === startServerCore.VIRTUAL_MODULES.startManifest) {
          return resolvedModuleId;
        }
        return void 0;
      }
    },
    load: {
      filter: {
        id: new RegExp(resolvedModuleId)
      },
      handler(id) {
        var _a;
        if (id === resolvedModuleId) {
          if (this.environment.config.consumer !== "server") {
            return `export default {}`;
          }
          if (config.command === "serve") {
            return `export const tsrStartManifest = () => ({
            routes: {}
          })`;
          }
          const APP_BASE = globalThis.TSS_APP_BASE;
          const clientViteManifestPath = path.resolve(
            opts.root,
            constants.CLIENT_DIST_DIR,
            ".vite",
            "manifest.json"
          );
          let viteManifest;
          try {
            viteManifest = JSON.parse(
              node_fs.readFileSync(clientViteManifestPath, "utf-8")
            );
          } catch (err) {
            console.error(err);
            throw new Error(
              `Could not find the production client vite manifest at '${clientViteManifestPath}'!`
            );
          }
          const routeTreeRoutes = globalThis.TSS_ROUTES_MANIFEST.routes;
          let entryFile;
          const filesByRouteFilePath = Object.fromEntries(
            Object.entries(viteManifest).map(([k, v]) => {
              if (v.isEntry) {
                if (entryFile !== void 0) {
                  console.error(
                    `multiple entries detected`,
                    entryFile.file,
                    v.file
                  );
                }
                entryFile = v;
              }
              const rPath = k.split("?")[0];
              return [rPath, v];
            }, {})
          );
          const routesDirectoryFromRoot = path.relative(
            opts.root,
            opts.tsr.routesDirectory
          );
          Object.entries(routeTreeRoutes).forEach(([routeId, v]) => {
            const file = filesByRouteFilePath[path.posix.join(routesDirectoryFromRoot, v.filePath)];
            if (file) {
              const preloads = (file.imports ?? []).map((d) => {
                const assetPath = ufo.joinURL(APP_BASE, viteManifest[d].file);
                return assetPath;
              });
              if (file.file) {
                preloads.unshift(path.join(APP_BASE, file.file));
              }
              const cssAssetsList = getCSSRecursively(
                file,
                filesByRouteFilePath,
                APP_BASE
              );
              routeTreeRoutes[routeId] = {
                ...v,
                assets: [...v.assets || [], ...cssAssetsList],
                preloads
              };
            }
          });
          if (entryFile) {
            routeTreeRoutes[routerCore.rootRouteId].preloads = [
              ufo.joinURL(APP_BASE, entryFile.file),
              ...((_a = entryFile.imports) == null ? void 0 : _a.map(
                (d) => ufo.joinURL(APP_BASE, viteManifest[d].file)
              )) || []
            ];
            const entryCssAssetsList = getCSSRecursively(
              entryFile,
              filesByRouteFilePath,
              APP_BASE
            );
            routeTreeRoutes[routerCore.rootRouteId].assets = [
              ...routeTreeRoutes[routerCore.rootRouteId].assets || [],
              ...entryCssAssetsList,
              {
                tag: "script",
                attrs: {
                  src: ufo.joinURL(APP_BASE, entryFile.file),
                  type: "module"
                }
              }
            ];
          }
          const recurseRoute = (route, seenPreloads = {}) => {
            var _a2;
            route.preloads = (_a2 = route.preloads) == null ? void 0 : _a2.filter((preload) => {
              if (seenPreloads[preload]) {
                return false;
              }
              seenPreloads[preload] = true;
              return true;
            });
            if (route.children) {
              route.children.forEach((child) => {
                const childRoute = routeTreeRoutes[child];
                recurseRoute(childRoute, { ...seenPreloads });
              });
            }
          };
          recurseRoute(routeTreeRoutes[routerCore.rootRouteId]);
          const routesManifest = {
            routes: routeTreeRoutes
          };
          return `export const tsrStartManifest = () => (${JSON.stringify(routesManifest)})`;
        }
        return void 0;
      }
    }
  };
}
exports.startManifestPlugin = startManifestPlugin;
//# sourceMappingURL=plugin.cjs.map
